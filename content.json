{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Mercy","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2016-12-23T00:37:50.000Z","updated":"2016-12-23T00:38:55.489Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构学习笔记（1） -- 表","slug":"数据结构学习笔记（1）-表","date":"2016-12-29T03:50:58.000Z","updated":"2017-01-04T02:54:39.954Z","comments":true,"path":"2016/12/29/数据结构学习笔记（1）-表/","link":"","permalink":"http://yoursite.com/2016/12/29/数据结构学习笔记（1）-表/","excerpt":"基础知识在数据结构中表的存储形式是线性（又称线性表）的，分为顺序存储（顺序表）和链式存储（链表） 顺序表： 即线性表用顺序存储结构保存数据，数据是连续的。 链表： 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。","text":"基础知识在数据结构中表的存储形式是线性（又称线性表）的，分为顺序存储（顺序表）和链式存储（链表） 顺序表： 即线性表用顺序存储结构保存数据，数据是连续的。 链表： 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。 顺序表和链表的简单对比图： 链表 链表分为单向链表，双向链表，单向循环链表，双向循环链表。 单链表 单链表 的每个节点上有两个部分，一个存储元素，另一个存储先一个节点地址的指针，其中尾节点的指针是null 单链表存储结构图： 单向循环链表 则是将尾节点的next指针指向头节点，这样就形成了环装（此处不给图了。） 双向链表 双向链表 每个节点有3个部分：上一个节点的指针，当前节点，下个节点的指针。其中头节点的pre指针是null，而尾节点的next指针是null 双链表存储结构图： 双向循环链表 则是将尾节点的next指针指向头节点，头节点的pre指针指向尾节点，这样就形成了环装（此处不给图了。） Java代码实现链表和顺序表 这里只提供了单链表和顺序表的简单功能实现，并没有考虑到高并发等的问题，代码中可能会出现不严谨的地方，欢迎大家批评指正。 单链表Java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284package test.collections;public class SingleLinkedList&lt;E&gt; &#123; private int size; private Node&lt;E&gt; first; private Node&lt;E&gt; last; /** * 添加 * * @param e * @return */ public boolean add(E e) &#123; // 默认添加到链表尾部，这就是为啥链接添加快的原因。 return addLast(e); &#125; /** * 向链表尾部添加一个元素 * * @param e * @return */ public boolean addLast(E e) &#123; Node&lt;E&gt; newNode = new Node&lt;E&gt;(e, null); Node&lt;E&gt; l = last; // size=0时，last和first都指向newNode。 last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; return true; &#125; /** * 向链表开头添加元素 * * @param e * @return */ public boolean addFirst(E e) &#123; Node&lt;E&gt; newNode = new Node&lt;E&gt;(e, null); Node&lt;E&gt; currentNode = first; first = newNode; if (currentNode == null) &#123; last = newNode; &#125; else &#123; newNode.next = currentNode; &#125; size++; return true; &#125; /** * 向链表指定位置添加元素 */ public boolean add(int index, E e) &#123; checkIndex(index); Node&lt;E&gt; newNode = new Node&lt;E&gt;(e, null); if (index == size) &#123; return addLast(e); &#125; else if (index == 0) &#123; addFirst(e); &#125; else &#123; Node&lt;E&gt; currentNode = first; for (int i = 0; i &lt; index - 1; i++) &#123; currentNode = currentNode.next; &#125; newNode.next = currentNode.next; // currentNode.next = newNode; // first = newNode; size++; &#125; return true; &#125; /** * 查看指定位置元素 * * @return */ public E get(int index) &#123; checkIndex(index); E e = null; Node&lt;E&gt; currentNode = first; if (index &gt; (size - 1)) return null; else &#123; // 每次查询元素时，都有遍历链表 index 次，时间复杂度为 o(index),这就是为啥链表查询慢的原因。 for (int i = 0; i &lt; index; i++) &#123; currentNode = currentNode.next; &#125; &#125; e = currentNode.item; return e; &#125; /** * 删除链表中的一个元素 * * @return */ public E remove() &#123; if (size == 0) return null; // 默认删除尾部，这就是为啥链表删除快的原因 return removeLast(); &#125; /** * 从链表尾部删除一个元素 * * @return */ public E removeLast() &#123; Node&lt;E&gt; l = last; --size; if (l == first) &#123; first = null; last = null; &#125; else &#123; Node&lt;E&gt; currentNode = first; for (int i = 0; i &lt; size - 1; i++) &#123; currentNode = currentNode.next; &#125; currentNode.next = null; last = currentNode; &#125; E e = l.item; l.item = null; l.next = null; l = null; return e; &#125; /** * 从链表头部删除一个元素 * * @return */ public E removeFirst() &#123; if (first == null) return null; size--; Node&lt;E&gt; f = first; first = f.next; E e = f.item; f.item = null; f.next = null; f = null; return e; &#125; /** * 删除指定元素 * * @param e * @return */ public E remove(E e) &#123; if (size &lt;= 0) return null; Node&lt;E&gt; currentNode = first; if (e.equals(currentNode.item)) &#123; removeFirst(); &#125; if(e.equals(last.item))&#123; removeLast(); &#125; for (int i = 0; i &lt; size; i++) &#123; if (e.equals(currentNode.item)) &#123; // 可以看出来，单链表中如果删除的元素不是头或尾，删除的时间复杂度还是非常高的。o(2n-1) remove(i); break; &#125; currentNode = currentNode.next; &#125; return e; &#125; /** * 删除指定位置元素 * * @param e * @return */ private void remove(int index) &#123; checkIndex(index); Node&lt;E&gt; currentNode = first; // last=null for (int j = 0; j &lt; index - 1; j++) &#123; currentNode = currentNode.next; &#125; Node&lt;E&gt; removeTarget = currentNode.next; currentNode.next = currentNode.next.next; removeTarget.item = null; removeTarget.next = null; removeTarget = null; size--; &#125; /** * 获取链表长度 * * @return */ public int size() &#123; return size; &#125; private void checkIndex(int index) &#123; if (!(index &gt;= 0 &amp;&amp; index &lt;= size)) &#123; System.out.println(\"Exception\"); throw new IndexOutOfBoundsException(\"Index out of size: \" + index + \";\"); &#125; &#125; /** * 节点类（内部类） * * @author mercy_yang * * @param &lt;E&gt; */ private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node(E e, Node&lt;E&gt; next) &#123; this.item = e; this.next = next; &#125; &#125; /** * 重写toString()方法 */ @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(\"[\"); for (int i = 0; i &lt; this.size(); i++) &#123; sb.append(this.get(i)).append((i + 1) == size ? \"\" : \", \"); &#125; sb.append(\"]\"); return sb.toString(); &#125; public static void main(String[] args) &#123; SIngleLinkedList&lt;String&gt; strList = new SIngleLinkedList&lt;String&gt;(); strList.add(\"A\"); strList.add(1, \"B\"); // String c = new String(\"C\"); // strList.add(c); // strList.add(\"D\"); // strList.add(\"E\"); // strList.add(\"F\"); // strList.add(\"G\"); strList.remove(\"A\"); strList.add(\"D\"); strList.add(\"G\"); // strList.add(\"G\"); System.out.println(strList.remove(\"G\")); strList.add(\"F\"); System.out.println(strList.size()); strList.add(\"F\"); System.out.println(strList); &#125;&#125; java 中的LinkedList就是双向链表存储格式，双向链表的添加和删除会比单链表更高效一点，有兴趣的可以看一下源码，对比一下。 顺序表的java实现 java 中的ArrayList就是典型的顺序表存储(数组)，这里就参考 ArrayList 实现一个自己的顺序表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179package test.collections;import java.util.ArrayList;import java.util.Arrays;/** * 顺便表的简单实现，底层维护一个数组 * 实现了：曾删查改 功能。 * @author mercy_yang * * @param &lt;E&gt; */public class MyArrayList&lt;E&gt; &#123; private int size; private Object[] elements; private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; private static final int INITAIL_SIZE = 10; public MyArrayList() &#123; this.elements = EMPTY_ELEMENTDATA; &#125; public MyArrayList(int capacity)&#123; this.elements=new Object[capacity]; &#125; /** * 默认向顺序表尾部插入元素 * @param e * @return */ public boolean add(E e) &#123; //当size超过顺序表长度是就自动扩充长度， //这是顺序表插入时主要耗时的地方，但是大部分向尾部插入速度还是很快的。 expandCapacity(size + 1); elements[size++] = e; return true; &#125; /** * 向指定位置添加元素 * 需要移动数组，这就是为啥顺序表插入元素慢的原因 * @param index * @param e * @return */ public boolean add(int index,E e)&#123; if (index==size) &#123; add(e); return true; &#125; checkIndex(index); expandCapacity(size+1); /* * 这里也可以直接使用 System.arraycopy(elements, index, elements, index+1, size-index); * 将elements数组从index的位置开始，移动到elements数组的index+1的位置，移动长度为（size-index） */ Object[] oldElements = elements; Object[] newElements =new Object[elements.length]; for(int i=0;i&lt;index;i++)&#123; newElements[i]=oldElements[i]; &#125; newElements[index] = e; for (int i = index; i &lt; size; i++) &#123; newElements[i+1] = oldElements[i]; &#125; elements=newElements; newElements=null; oldElements=null; size++; return true; &#125; /** * 扩充顺序表的长度 * @param capacity */ private void expandCapacity(int capacity) &#123; if (capacity &lt; INITAIL_SIZE) &#123; capacity = Math.max(INITAIL_SIZE, capacity); elements = Arrays.copyOf(elements, capacity); &#125; else if(capacity-elements.length&gt;0)&#123; int length = elements.length; int newCapacity = length + (length &gt;&gt; 1); elements = Arrays.copyOf(elements, newCapacity); &#125; &#125; /** * 查询元素 * 直接通过下标访问，时间复杂度为o(1) * @param i * @return */ @SuppressWarnings(\"unchecked\") public E get(int i)&#123; return (E)elements[i]; &#125; /** * 删除元素时间，复杂度最慢为o(n) * @param index * @return */ public E remove(int index)&#123; checkIndex(index); E oldValue = (E) get(index); if((index+1)&lt;size)&#123; System.out.println(\"移动数组\"); Object[] oldElements = elements; Object[] newElements =new Object[elements.length]; for(int i=0;i&lt;index;i++)&#123; newElements[i]=oldElements[i]; &#125; for (int i = index+1; i &lt; size; i++) &#123; newElements[i-1] = oldElements[i]; &#125; elements=newElements; newElements=null; oldElements=null; &#125; elements[--size]=null; return oldValue; &#125; /** * 修改元素，时间复杂读为o(1) * @param index * @param e * @return */ public boolean set(int index ,E e)&#123; checkIndex(index); elements[index] = e; return true; &#125; private void checkIndex(int index) &#123;// if(!(index&gt;0&amp;&amp;index&lt;size))&#123; if(index&lt;0||index&gt;size)&#123; throw new IndexOutOfBoundsException(\"Index out of size: \"+index); &#125; &#125; public int size()&#123; return size; &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(\"[\"); for (int i = 0; i &lt; size; i++) &#123; sb.append(this.get(i)).append((i+1)==size?\"\":\", \"); &#125; sb.append(\"]\"); return sb.toString(); &#125; public static void main(String[] args) &#123; MyArrayList&lt;String&gt; arrayStr = new MyArrayList&lt;String&gt;(); arrayStr.add(\"A\"); arrayStr.add(\"B\"); arrayStr.add(\"C\"); arrayStr.add(\"D\"); arrayStr.add(3,\"C\"); arrayStr.add(4,\"i\"); arrayStr.add(2,\"i\"); arrayStr.add(0,\"o\"); arrayStr.add(8,\"o\");// System.err.println(arrayStr.elements.length);// System.out.println(arrayStr.size()); arrayStr.remove(9); arrayStr.remove(1); System.out.println(arrayStr); &#125;&#125; 这里只是参考ArrayList简单的实现了一个顺序表存储。其中在 remove(int index,E e) 和 add(int index,E e) 方法中模拟 System.arraycopy(elements, index, elements, index+1, size-index); 实现了数组了copy， 只是为了说明顺序表在添加和删除速度偏慢是因为需要移动数组。 Java 中 LinkedList和ArrayList性能对比 推荐大家自己动手对比一下 LinkedList 和 ArrayList 的增删查改的速度，其实 ArrayList 在增删时不一定比 LinkedList 慢。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"自定义checkbox样式","slug":"自定义checkbox样式","date":"2016-12-28T01:01:09.000Z","updated":"2017-01-04T01:08:17.294Z","comments":true,"path":"2016/12/28/自定义checkbox样式/","link":"","permalink":"http://yoursite.com/2016/12/28/自定义checkbox样式/","excerpt":"通过css来自定义checkbox样式截图： 原生的 checkbox 和 自定义 checkbox 比较","text":"通过css来自定义checkbox样式截图： 原生的 checkbox 和 自定义 checkbox 比较 思路与步骤 首先禁止默认的checkbox显示 123.checkbox&#123;display: none;&#125; 使用其他的 span(或者其他的标签也行，如： ) 来表示成 checkbox 的外观 1234&lt;label class=\"checkbox-label\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\"/&gt; &lt;span class=\"glyphicon glyphicon-ok checkbox-span\"&gt;&lt;/span&gt; &lt;!-- 这里span里的 glyphicon glyphicon-ok 的class是bootstrap提供的图标类，即对勾图标--&gt;&lt;/label&gt; 这里的原理就是，点击紧跟在checkbox后面的内容就可以选中这个checkbox,所以我们只需要为跟在后面的这个 span 添加css样式，变为我们想要的样子。下面我们就开始改变这个span，这里用到的 bootstrap 提供的对勾（√）图标，大家可以自行google使用它。 接下来就是为 class checkbox-span 定义css样式 123456789101112131415161718192021222324252627/* 选中之前的样式 */.checkbox-span&#123; background-color: #fff; border: 1px solid rgba(0, 0, 0, 0.15); display: inline-block; margin-right: 10px; vertical-align: middle; height: 17px; width: 17px; font-size: 15px; line-height: 1; color: #fff; box-shadow: 0 0 0px rgba(111, 111, 111, 0.5), 0px 0px 10px rgba(111, 111, 111, 0.5);&#125;/* 选中之后的样式 */.checkbox:checked+.checkbox-span &#123; background-color: #399CFF; display: inline-block; box-shadow: 0 0 0px rgba(0, 204, 204, .5),0px 0px 10px rgba(0, 204, 204, .5);&#125;/* 鼠标悬浮的样式 */.checkbox+span:hover &#123; box-shadow: 0 0 0px rgba(0, 204, 204, .5),0px 0px 10px rgba(0, 204, 204, .5);&#125; 到这里我们就大功告成了，下面就贴出完整例子 完整html代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"static/css/bootstrap.min.css\"&gt; &lt;style&gt; .checkbox &#123; display: none; &#125; /* 选中之前的样式 */ .checkbox-span &#123; background-color: #fff; border: 1px solid rgba(0, 0, 0, 0.15); display: inline-block; margin-right: 10px; vertical-align: middle; height: 17px; width: 17px; font-size: 15px; line-height: 1; color: #fff; box-shadow: 0 0 0px rgba(111, 111, 111, 0.5), 0px 0px 10px rgba(111, 111, 111, 0.5); &#125; /* 选中之后的样式 */ .checkbox:checked+.checkbox-span &#123; background-color: #399CFF; display: inline-block; box-shadow: 0 0 0px rgba(0, 204, 204, .5), 0px 0px 10px rgba(0, 204, 204, .5); &#125; /* 鼠标悬浮的样式 */ .checkbox+.checkbox-span:hover &#123; box-shadow: 0 0 0px rgba(0, 204, 204, .5), 0px 0px 10px rgba(0, 204, 204, .5); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;label class=\"checkbox-label\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" /&gt; &lt;span class=\"glyphicon glyphicon-ok checkbox-span\"&gt;&lt;/span&gt; &lt;!-- 这里span里的 fa fa-check 的class是bootstrap提供的图标类，即对勾图标--&gt; &lt;/label&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"java static、final关键字.md","slug":"java-static、final关键字-md","date":"2016-12-22T08:00:12.000Z","updated":"2017-01-04T01:07:46.238Z","comments":true,"path":"2016/12/22/java-static、final关键字-md/","link":"","permalink":"http://yoursite.com/2016/12/22/java-static、final关键字-md/","excerpt":"static 的基本用法和执行顺序基础概念 1被static修饰的属性，字段，方法，块等，都会在类加载时被初始化，且只初始化一次，由static修饰的字段被类所有实例所共享。","text":"static 的基本用法和执行顺序基础概念 1被static修饰的属性，字段，方法，块等，都会在类加载时被初始化，且只初始化一次，由static修饰的字段被类所有实例所共享。 这里补充一下，类何时被加载： 123456- 创建类实例时。- 访问类的静态变量（注意这里指的是变量，如果是静态常量&lt;static final&gt;则不会初始化类，这个后面会讲到）。- 调用类的静态方法时。- 反射（如：Class.forName(xxx.xxx.XXXX)。- 该类子类被初始化时，父类也会被初始化。（但是直接通过子类引用调用父类静态元素，子类不会被加载）- Java虚拟机被标明为启动类的类（如 main() 方法） 有了上面的概念，我再来看代码 执行顺序准备： 123456789101112131415161718class Grandpa&#123; public static String grandpa_value=\"I am your grandpa...\"; static&#123; System.out.println(\"Grandpa static area...\"); &#125; public Grandpa() &#123; System.out.println(\"Grandpa's constructor\"); &#125;&#125;public class StaticFinalDemo &#123; public static void main(String[] args) &#123; Grandpa gp1 = new Grandpa(); Grandpa gp2 = new Grandpa(); &#125;&#125; 执行结果： 1234I am your grandpa...Grandpa static area...Grandpa&apos;s constructor...Grandpa&apos;s constructor... 上面的例子就是典型的在新建 Grandpa 实例时，时加载 Grandpa 类,且由static修饰块或字段优先于类的构造函数执行，且类只执行一次（每次new对象时都会执行构造函数）。 子类初始化父类基于上面的代码，我们加上： 12345678910111213141516171819202122232425class Father extends Grandpa&#123; public static String father_value=\"I am your father...\"; static&#123; System.out.println(father_value); System.out.println(\"Father static area...\"); &#125; public Father() &#123; System.out.println(\"Father's constructor...\"); &#125;&#125;class Son extends Father&#123; public static String son_value=\"I am Son...\"; static&#123; System.out.println(son_value); System.out.println(\"Son static area...\"); &#125; public Son() &#123; System.out.println(\"Son's constructor...\"); &#125;&#125; 再在修改 StaticFinalDemo 的 main() 方法： 1Son s = new Son(); 执行结果： 123456789I am your grandpa...Grandpa static area...I am your father...Father static area...I am Son...Son static area...Grandpa&apos;s constructor...Father&apos;s constructor...Son&apos;s constructor... 可以看到，在初始化Son类时，Son父类（Father、Grandp）都被初始化了，且顺序是 Grandpa &gt; Father &gt; Son 我们再次修改一下 main() 方法： 1Father f = new Father(); 123456I am your grandpa...Grandpa static area...I am your father...Father static area...Grandpa&apos;s constructor...Father&apos;s constructor... 可以看出，父类 Father 的初始化没有初始化子类 Son。 未完待续… 其他 static 使用场景1. 静态内部类2. 静态导包final 使用","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"postgresql 索引.md","slug":"postgresql-索引-md","date":"2016-12-20T07:20:57.000Z","updated":"2017-01-04T01:08:03.018Z","comments":true,"path":"2016/12/20/postgresql-索引-md/","link":"","permalink":"http://yoursite.com/2016/12/20/postgresql-索引-md/","excerpt":"索引的基础知识索引是一种特殊的查询表，可以使用搜索引擎的数据库以加快数据检索。简单地说，索引是表中的数据的一个指针，在一个数据库中的索引是非常相似，如：一本书的目录。","text":"索引的基础知识索引是一种特殊的查询表，可以使用搜索引擎的数据库以加快数据检索。简单地说，索引是表中的数据的一个指针，在一个数据库中的索引是非常相似，如：一本书的目录。例如，如果想在一本书中引用的所有页面讨论某个话题，先参考索引按字母顺序列出所有目录主题，然后转到一个或多个特定的页码。 索引有助于加快SELECT查询和WHERE子句，但它会减慢数据的输入，UPDATE和INSERT语句。索引可以创建或删除的数据没有影响。 创建索引涉及CREATE INDEX语句，它允许命名的索引，索引指定表的一列或多列，并指示索引是否在升序或降序排列。 索引也可以是唯一的，类似UNIQUE约束，在列上有一个索引的列或组合索引防止重复项。 准备工作建表 12345678-- Table: t3-- DROP TABLE t3;CREATE TABLE t3( a character varying(10), b character varying(10), c character varying(10)) 插入数据 （运行几十次，插入几十万跳记录） 1INSERT INTO t3 values(generate_series(1,10000)||&apos;a&apos;,generate_series(1,10000)||&apos;b&apos;,generate_series(1,10000)||&apos;c&apos;) 创建索引在创建索引之前先看一下执行查询语句的时间： 1EXPLAIN ANALYZE SELECT a,b,c FROM t3 WHERE a=&apos;1a&apos;; 执行结果如下：(注意比较最好一行的 “Total runtime: xxx”) 接着创建在 column（a）上的索引，语句： 1CREATE INDEX idx_t3_a ON t3(a) 再次执行上面的查询语句，执行结果如下： 索引的类别PostgreSQL提供了几种索引类型：B-树，哈希，GIST，SP-GiST和GIN。每个索引类型使用不同的算法，是最适合于不同类型的查询。默认情况下，CREATE INDEX命令创建B-tree索引，适合最常见的情况。 单列索引刚刚创建的在column（a）上的索引，就是一个单列索引。 多列索引语句 1CREATE INDEX idx_t3_abc ON t3(a,b,c) 是否要创建一个单列索引或多列索引，要根据该列是否在where频繁使用。另外需要注意 的是创建多列索引有一个 最左前缀原则 ，即想要使用多列索引就必须要在where子句中出现多列索引的最左列，即本例中的 a 列。 没有加入条件 a ： 1EXPLAIN ANALYZE SELECT a,b,c FROM t3 where b=&apos;1b&apos; and c=&apos;1c&apos; 运行结果： 加入条件 a： 1EXPLAIN ANALYZE SELECT a,b,c FROM t3 where b=&apos;1b&apos; and c=&apos;1c&apos; and a=&apos;1a&apos; 运行结果： 部分索引部分索引是一个索引建在一个表的一个子集，该子集是一个条件表达式定义的（叫做部分索引的谓词）。该指数包含的条目只有那些满足谓词的表行。基本语法如下： 1CREATE INDEX idx_t3_c_1c ON t3(c) WHERE c=&apos;1c&apos; 执行查询，当条件为 c=’10c’ 时： 1EXPLAIN ANALYZE SELECT a,b,c FROM t3 where c=&apos;10c&apos; 执行结果： 执行查询，当条件为 c=’1c’ 时： 1EXPLAIN ANALYZE SELECT a,b,c FROM t3 where c=&apos;1c&apos; 执行结果： 何时不该创建索引虽然索引的目的在于提高数据库的性能，有时间时，应避免。使用索引时，应重新考虑下列准则： 索引不应该用在数据量小的表上。 有频繁的大量的插入或更新的操作的表。 索引不应包含有大量null值的列。 频繁操作的列都将不建议使用索引。 参考 【易百】http://www.yiibai.com/html/postgresql/2013/080674.html","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"javascript 对象.md","slug":"javascript-对象-md","date":"2016-12-19T02:09:18.000Z","updated":"2017-01-04T01:07:50.110Z","comments":true,"path":"2016/12/19/javascript-对象-md/","link":"","permalink":"http://yoursite.com/2016/12/19/javascript-对象-md/","excerpt":"JavaScript内置对象 javascript 有很多内置对象, 如：Object, Function, Array, Date, RegExp, Math, Error, Symbol, String, Number, Boolean.","text":"JavaScript内置对象 javascript 有很多内置对象, 如：Object, Function, Array, Date, RegExp, Math, Error, Symbol, String, Number, Boolean. JavaScript的祖先和两位长老 万物皆空 ，从上图可以看出来，JavaScript的祖先 NULL ，而两位长老分别是： Object.prototype、Function.prototype 。 原型指针（__proto__)和原型对象(prototype) 1). 原型指针（__proto__): 每个对象都有个原型指针指向该对象的原型对象 1Object.prototype.__proto__ === null //true,所以Object.prototype的原型是null。 1234567891011var Person = function(name)&#123;this.name = name;&#125;;p1 = new Person(&apos;zhnagsan&apos;);p2 = new Person(&apos;lisi&apos;);p1.__proto__===Person.prototype //truep2.__proto__===Person.prototype //truep1.__proto__ === p2.__proto__ //truePerson.__proto__ === Function.prototype //truePerson.__proto__.__proto__ ===Object.prototype //truePerson.__proto__.__proto__.__proto__ === null //true 值得注意的是，按照语言标准，__proto__ 属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeof和Object.setPrototypeOf，进行原型对象的读写操作。 2). 原型对象（prototype）: 每个函数对象都有 prototype 属性，这里需要注意的是：只有函数对象才有 prototype 属性,函数对象也是对象，同时也拥有 __proto__ 属性，指向 Function.prototype . 12345var Person = function(name)&#123;this.name=name;&#125;console.log(Person.prototype); // --&gt; Object &#123;...&#125;Person.__proto__ === Function.prototype; // true 每个原型对象都有自己的构造函数 constructor,并且构造函数指向对象本身： 1Person.prototype.constructor === Person //true, Person.prototype.constructor指向对象本身 一般将一些对象公用的方法定义在对象的原型对象里： 1234567Person.prototype.sayName =function sayName()&#123;console.log(this.name);&#125;p1 = new Person(&apos;zhnagsan&apos;);p2 = new Person(&apos;lisi&apos;);console.log(p1.sayName()); // zhangsanconsole.log(p2.sayName()); //lisi 3). 用两张图来表示原型对象和原型指针的关系： 1var a = new Array(); 12var Foo = function() &#123;&#125;var a = new Foo(); 再说两位长老从上可以看书出，JavaScript中的两位长老 Object.prototype,Function.prototype。可以这样总结这两个对象： Object.prototype 是所有函数对象的原型对象的原型（即 *.prototype.__proto__ 所指的对象）,也是普通对象的原型。 Function.prototype 是所有函数对象的原型（即 *.__proto__) ps： 这里的 * 都指的是 函数对象。 123456var obj = &#123;a:1&#125;;obj.__proto__ === Object.prototype // truevar fun = function()&#123;&#125; fun.__proto__ === Function.prototype // truefun.prototype instanceof Object //truefun.prototype.__proto__ //true 本文参考： http://www.jianshu.com/p/3bb6f208e459","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"linux 常用命令总结.md","slug":"linux-常用命令总结-md","date":"2016-12-16T04:43:57.000Z","updated":"2017-01-04T01:07:59.406Z","comments":true,"path":"2016/12/16/linux-常用命令总结-md/","link":"","permalink":"http://yoursite.com/2016/12/16/linux-常用命令总结-md/","excerpt":"ls: 1ls -al","text":"ls: 1ls -al touch :创建文件 12touch + [pram] + [filename] touch -t 201111051200 file1 //指定创建时间 cp 123456//主要用法cp -l file1 file2 //为file1创建硬链接cp -s file1 file2 //为file1创建软链接，相当于 ln命令//其他参数-R //copy目录，递归-p //保留文件属性 rm 12rm -r // 删除目录，递归rm -f //强制删除 mv 12// 常用与给文件或目录重命名mv [file1] [file2] cat 123//查看文件内容cat -n [file] //给显示的文件加上行数cat -b [file] //只给有内容的行显示行数 more ， less 123//更方便的额查看文件more [file]less [file] // less是more的升级版 ，大致功能类似 tail ， head 12345tail // 查看文件末尾head // 查看文件开头//常用tail -f [file] // 这个命令常用来查看log 文件，可以让tail一直保持活跃，有新的内容就会显示。head -n [file] // n是数字， 查看开头n行的内容 | ， grep 1234 | 符号在Linux中是一种管道。cat [file] | more // 通过 | 将输出转到 more程序中grep //是过滤操作 ，通常和 | 搭配使用cat HttpGetRequest.java | grep if // 从 HttpGetRequest.java中 所有包含 ‘if’ 的行 ps 1234// ps 是Linux中常用命令，用来查看进程的，常用的参数有ps -e // 查看所有的进程ps -f // 完整格式显示输出ps -ef | grep tomcat // 查看包含 tomat 的进程","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"first","slug":"first","date":"2016-12-16T03:48:57.000Z","updated":"2016-12-16T03:49:44.794Z","comments":true,"path":"2016/12/16/first/","link":"","permalink":"http://yoursite.com/2016/12/16/first/","excerpt":"","text":"Hello World","categories":[],"tags":[]}]}